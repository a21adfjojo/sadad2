<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>NIMBY Rail Clone - オンライン鉄道シミュレーション</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <style>
      /* 基本スタイル */
      body {
        margin: 0;
        overflow: hidden;
      }
      #map {
        height: 100vh;
        width: 100%;
        background-color: white;
      }

      .rail-ui-control,
      #game-stats,
      #login-overlay,
      #ranking-panel {
        background-color: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border: 2px solid #333;
        border-radius: 5px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        font-family: Arial, sans-serif;
        z-index: 1000;
        position: absolute;
      }

      /* ログインオーバーレイ */
      #login-overlay {
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 2000;
      }
      #login-panel {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        text-align: center;
      }

      /* UIコントロールのスタイル修正: スクロール可能にする */
      .rail-ui-control {
        top: 10px;
        left: 10px;
        width: 300px;
        max-height: 95vh; /* 画面の高さに合わせて最大高さを設定 */
        overflow-y: auto; /* 縦方向のスクロールを有効にする */
      }

      /* UIコンソール位置 */
      #game-stats {
        top: 10px;
        right: 10px;
        width: 300px;
        line-height: 1.5;
      }
      #ranking-panel {
        bottom: 10px;
        right: 10px;
        width: 300px;
      }

      /* アコーディオンヘッダー */
      .accordion-header {
        cursor: pointer;
        background-color: #f0f0f0;
        padding: 5px;
        border-bottom: 1px solid #ccc;
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .accordion-content {
        padding-top: 10px;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }
      .accordion-content.open {
        max-height: 1000px;
      }

      /* ボタン・セレクト */
      .rail-ui-control button,
      .rail-ui-control select {
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        border: 1px solid #555;
        background-color: #f5f5f5;
        border-radius: 3px;
        margin: 2px 0;
        width: 100%;
        box-sizing: border-box;
      }
      .rail-ui-control button.active {
        background-color: #007bff !important;
        color: white;
        border-color: #0056b3;
      }
      .time-display {
        font-size: 1.2em;
        font-weight: bold;
        color: #0044bb;
        margin-bottom: 10px;
      }

      /* 列車アイコンの調整 */
      .train-icon {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 2px solid #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        transform: translate(-50%, -50%);
      }
      .station-icon {
        background-color: #000;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        border: 3px solid #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        cursor: pointer;
      }
      .leaflet-container.station-mode {
        cursor: crosshair;
      }
      .leaflet-container.dismantle-station-mode .station-icon {
        border-color: #ff0000;
        cursor: crosshair;
      }
      .leaflet-container.dismantle-line-mode {
        cursor: crosshair;
      }

      #error-message,
      #info-message {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 3000;
        display: none;
      }
      #error-message {
        background-color: #ff4444;
        color: white;
      }
      #info-message {
        background-color: #44aaff;
        color: white;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <!-- ログインオーバーレイ -->
    <div id="login-overlay">
      <div id="login-panel">
        <h2>オンライン鉄道シムへようこそ</h2>
        <p>
          ランキングに参加するため、ユーザー名とパスワードを入力してください。<br /><small
            >（新規ユーザーは任意のパスワードで登録できます）</small
          >
        </p>
        <input
          type="text"
          id="username-input"
          placeholder="ユーザー名"
          style="padding: 10px; margin-bottom: 10px; width: 80%"
        />
        <input
          type="password"
          id="password-input"
          placeholder="パスワード"
          style="padding: 10px; margin-bottom: 10px; width: 80%"
        />
        <button onclick="handleLogin()" style="width: 80%">
          ログイン / 参加
        </button>
      </div>
    </div>

    <!-- ゲーム統計 (右上のUI) -->
    <div id="game-stats">
      <div class="accordion-header" onclick="toggleAccordion('stats-content')">
        <span>📊 ゲーム統計・時間 <span id="stats-toggle-icon">▼</span></span>
      </div>
      <div id="stats-content" class="accordion-content open">
        <p class="time-display">
          日時: <span id="game-date-time">同期中...</span>
        </p>
        <p>倍速: <span id="time-scale-display">x60</span> (サーバー制御)</p>
        <hr />
        <h3>💰 経営状況 (あなた)</h3>
        <p>資金: <span id="money-display">¥0</span></p>
        <p>総資産: <span id="asset-display">¥0</span></p>
        <p>月次維持費: <span id="maint-cost-display">¥0</span></p>
        <p>
          車両数: <span id="vehicle-count">0</span> | 駅数:
          <span id="station-count">0</span>
        </p>
      </div>
    </div>

    <!-- 建設・車両コントロール (左上のUI) -->
    <div class="rail-ui-control">
      <div
        class="accordion-header"
        onclick="toggleAccordion('control-content')"
      >
        <span>🛠️ 建設・車両操作 <span id="control-toggle-icon">▼</span></span>
      </div>
      <div id="control-content" class="accordion-content open">
        <div style="text-align: center; margin-bottom: 10px">
          <button
            id="btn-station-mode"
            onclick="toggleConstructionMode('station')"
          >
            🏠 駅モード (¥50M)
          </button>
          <button id="btn-track-mode" onclick="toggleConstructionMode('track')">
            🛤️ 路線モード
          </button>
          <button onclick="finalizeLine()" style="margin-top: 5px">
            ✅ 路線を確定
          </button>

          <hr
            style="margin: 10px 0; border: none; border-top: 1px solid #ccc"
          />

          <!-- 解体モードのボタン -->
          <button
            id="btn-dismantle-station-mode"
            onclick="toggleConstructionMode('dismantle-station')"
            style="background-color: #ffc0cb"
          >
            💥 駅解体モード
          </button>
          <button
            id="btn-dismantle-line-mode"
            onclick="toggleConstructionMode('dismantle-line')"
            style="background-color: #ffc0cb"
          >
            💣 路線解体モード
          </button>

          <hr
            style="margin: 10px 0; border: none; border-top: 1px solid #ccc"
          />

          <button onclick="toggleConstructionMode('idle')">
            ❌ 建設キャンセル/アイドル
          </button>

          <hr
            style="margin: 10px 0; border: none; border-top: 1px solid #ccc"
          />

          <label style="display: block; margin-bottom: 5px; font-weight: bold"
            >線路タイプ:</label
          >
          <select id="track-type" onchange="Game.currentTrackType = this.value">
            <option value="single">単線 (x1.0)</option>
            <option value="double">複線 (x1.8)</option>
            <option value="linear">リニア専用 (x5.0)</option>
            <option value="tram">路面電車専用 (x0.8)</option>
          </select>
        </div>
        <div id="vehicle-buy-container"></div>
      </div>
    </div>

    <!-- ランキングパネル (右下のUI) -->
    <div id="ranking-panel">
      <div
        class="accordion-header"
        onclick="toggleAccordion('ranking-content')"
      >
        <span
          >🏆 ランキング (対戦要素)
          <span id="ranking-toggle-icon">▼</span></span
        >
      </div>
      <div id="ranking-content" class="accordion-content open">
        <ol id="ranking-list">
          <li>サーバーからデータを同期中...</li>
        </ol>
      </div>
    </div>

    <!-- エラーメッセージ表示領域 -->
    <div id="error-message" style="display: none"></div>
    <div id="info-message" style="display: none"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <script>
      // =========================================================
      // A. ゲーム定数と状態 (クライアント側)
      // =========================================================
      const INITIAL_LAT = 35.681236;
      const INITIAL_LNG = 139.767125;
      const STATION_COST = 50000000;
      const VEHICLE_BASE_COST = 8000000;

      let VehicleData = {};
      let map; // Leafletマップインスタンス

      const Game = {
        userId: null,
        money: 0,
        totalConstructionCost: 0,
        establishedLines: [],
        allLines: {},
        stations: [],
        vehicles: [],
        allTrainMarkers: {},
        mode: "idle",
        currentTrackType: "single",
        
        // 💡 修正点 4: UI更新のトリガー用変数を追加
        _lastLineCount: 0,
        _lastVehicleCount: 0,

        updateStats(data) {
          // 資金、建設コスト、車両、路線情報を更新
          this.money = data.money !== undefined ? data.money : this.money;
          this.totalConstructionCost =
            data.totalConstructionCost !== undefined
              ? data.totalConstructionCost
              : this.totalConstructionCost;
          this.establishedLines =
            data.establishedLines !== undefined
              ? data.establishedLines
              : this.establishedLines;
          this.vehicles =
            data.vehicles !== undefined ? data.vehicles : this.vehicles;

          if (data.stations) this.drawStations(data.stations);
          if (data.allLines) this.drawLines(data.allLines);

          this.updateFinancialUI();
        },
        
        updateFinancialUI() {
            // 総資産の再計算: 資金 + 建設コストの70% (減価償却を考慮) + 車両の購入価格
            const totalAsset =
                this.money +
                this.totalConstructionCost * 0.7 +
                this.vehicles.length * VEHICLE_BASE_COST;
                
            document.getElementById("money-display").textContent = `¥${Math.round(
                this.money
            ).toLocaleString()}`;
            document.getElementById("asset-display").textContent = `¥${Math.round(
                totalAsset
            ).toLocaleString()}`;
            document.getElementById("vehicle-count").textContent =
                this.vehicles.length;
        },

        updateGlobalStats(data) {
          const gameTime = new Date(data.time);
          document.getElementById("game-date-time").textContent =
            this.formatDateTime(gameTime);
          document.getElementById(
            "time-scale-display"
          ).textContent = `x${data.globalStats.timeScale}`;
          document.getElementById("maint-cost-display").textContent = `¥${(
            data.globalStats.lastMonthlyMaintenance || 0
          ).toLocaleString()}`;
          document.getElementById("station-count").textContent =
            data.globalStats.stationsCount;
            
          // 資金が変動している可能性があるため、財務UIを更新
          this.updateFinancialUI();
        },

        formatDateTime(date) {
          const year = date.getFullYear();
          const month = date.getMonth() + 1;
          const day = date.getDate();
          const hour = date.getHours().toString().padStart(2, "0");
          return `${year}年${month}月${day}日 ${hour}時`;
        },

        drawStations(stations) {
          this.stations.forEach((s) => map.removeLayer(s.marker));
          this.stations = [];
          stations.forEach(
            (s) =>
              new Station(
                s.id,
                { lat: s.latlng[0], lng: s.latlng[1] },
                map,
                s.ownerId
              )
          );
        },

        drawLines(lines) {
          Object.values(this.allLines).forEach((l) => map.removeLayer(l));
          this.allLines = {};
          // lines は全ユーザーの路線データ
          lines.forEach((line) => this.drawLine(line));
        },

        drawLine(line) {
          let weight = 8;
          if (line.trackType === "double") weight = 12;
          else if (line.trackType === "linear") weight = 15;
          else if (line.trackType === "tram") weight = 6;

          // 自分の路線は太く、他人の路線は細くするなどの調整も可能
          const isMyLine = line.ownerId === Game.userId;
          const finalStyle = {
            color: line.color,
            weight: isMyLine ? weight : weight * 0.7, // 他人の路線は少し細く
            opacity: isMyLine ? 1 : 0.7, // 他人の路線は少し薄く
            lineCap: "round",
          };
          this.allLines[line.id] = L.polyline(line.coords, finalStyle)
            .addTo(map);
        },
      };

      let socket;
      let drawingPolyline = null;
      let lineCandidateNodes = [];

      class Station {
        constructor(id, latlng, map, ownerId) {
          this.id = id;
          this.latlng = latlng;
          this.ownerId = ownerId;
          this.name = `駅 ${id}`;

          // 自分の駅は青、他人の駅は赤
          const stationColor = ownerId === Game.userId ? "#0044BB" : "#FF0000";

          this.marker = L.marker(latlng, {
            icon: L.divIcon({
              className: "station-icon",
              style: `background-color: ${stationColor};`,
            }),
            title: this.name,
          }).addTo(map);

          this.marker.bindPopup(
            `<b>${this.name} (ID: ${this.id})</b><br>Owner: ${ownerId}`
          );
          this.marker.on("click", (e) => {
            if (Game.mode === "track" || Game.mode === "dismantle-station") {
              handleStationClick(this);
              L.DomEvent.stopPropagation(e); // Leafletのイベント伝播を停止
              
              // 元のDOMイベントの伝播も停止し、UIの安定性を向上
              if (e.originalEvent) {
                  e.originalEvent.stopPropagation();
              }
            }
          });
          Game.stations.push(this);
        }
      }

      // =========================================================
      // C. サーバー通信と認証
      // =========================================================

      function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(";");
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === " ") c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0)
            return c.substring(nameEQ.length, c.length);
        }
        return null;
      }

      async function handleLogin() {
        const username = document.getElementById("username-input").value.trim();
        const password = document.getElementById("password-input").value.trim();

        if (username.length < 3 || password.length === 0) {
          alert("ユーザー名とパスワードを入力してください。");
          return;
        }

        try {
          const response = await fetch("/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username: username, password: password }),
          });
          const data = await response.json();

          if (data.success) {
            Game.userId = data.userId;
            document.getElementById("login-overlay").style.display = "none";
            connectSocket(Game.userId);
          } else {
            alert("ログイン失敗: " + data.message);
          }
        } catch (error) {
          console.error("ログインエラー:", error);
          alert("サーバーとの通信に失敗しました。");
        }
      }

      function connectSocket(userId) {
        socket = io();

        socket.on("connect", () => {
          socket.emit("login", { userId: userId });
        });

        socket.on("initialState", (data) => {
          VehicleData = data.vehicleData;
          Game.updateStats(data);
          
          if (data.allLines) {
            Game.drawLines(data.allLines);
          }
          
          // 💡 修正点 5: 初回は必ずUIを更新し、カウントを初期化
          updateVehicleBuyUI();
          Game._lastLineCount = data.establishedLines ? data.establishedLines.length : 0;
          Game._lastVehicleCount = data.vehicles ? data.vehicles.length : 0;
        });

        socket.on("updateUserState", (data) => {
          // 資金、建設コスト、車両リストが更新される (リアルタイム収益更新を含む)
          Game.updateStats(data);
          
          // 💡 修正点 6: 路線数または車両数に変化があった場合のみUIを更新
          const currentLineCount = data.establishedLines ? data.establishedLines.length : Game._lastLineCount;
          const currentVehicleCount = data.vehicles ? data.vehicles.length : Game._lastVehicleCount;

          if (currentLineCount !== Game._lastLineCount || currentVehicleCount !== Game._lastVehicleCount) {
              updateVehicleBuyUI();
              Game._lastLineCount = currentLineCount;
              Game._lastVehicleCount = currentVehicleCount;
          }
        });

        socket.on("gameUpdate", (data) => {
          // 時間、月次維持費、駅数などが更新される (全ユーザー向け)
          Game.updateGlobalStats(data);
          updateTrainPositions(data.trainPositions);
        });

        socket.on("rankingUpdate", (ranking) => {
          updateRankingUI(ranking);
        });

        socket.on("stationBuilt", (data) => {
          new Station(data.id, data.latlng, map, data.ownerId);
          // 駅数が変わったので、グローバル統計を再描画
          Game.updateGlobalStats({ globalStats: { stationsCount: Game.stations.length } });
        });

        socket.on("lineBuilt", (data) => {
          Game.drawLine(data);
          // 自分の路線リストの更新はupdateUserStateに任せる
        });

        socket.on("lineDismantled", (data) => {
          if (Game.allLines[data.lineId]) {
            map.removeLayer(Game.allLines[data.lineId]);
            delete Game.allLines[data.lineId];
          }
          // 自分の路線リストの更新はupdateUserStateに任せる
        });

        socket.on("stationDismantled", (data) => {
          const stationIndex = Game.stations.findIndex(
            (s) => s.id === data.stationId
          );
          if (stationIndex !== -1) {
            map.removeLayer(Game.stations[stationIndex].marker);
            Game.stations.splice(stationIndex, 1);
          }
          // 駅数が変わったので、グローバル統計を再描画
          Game.updateGlobalStats({ globalStats: { stationsCount: Game.stations.length } });
        });

        socket.on("error", (message) => {
          const errorDiv = document.getElementById("error-message");
          errorDiv.textContent = message;
          errorDiv.style.display = "block";
          setTimeout(() => {
            errorDiv.style.display = "none";
          }, 5000);
        });

        socket.on("info", (message) => {
          const infoDiv = document.getElementById("info-message");
          infoDiv.textContent = message;
          infoDiv.style.display = "block";
          setTimeout(() => {
            infoDiv.style.display = "none";
          }, 5000);
        });
      }

      function updateTrainPositions(trainPositions) {
        trainPositions.forEach((train) => {
          if (Game.allTrainMarkers[train.id]) {
            Game.allTrainMarkers[train.id].setLatLng(train.latlng);
          } else {
            const marker = L.divIcon({
              className: "train-icon",
              style: `background-color: ${train.color}; border-color: ${
                train.owner === Game.userId ? "yellow" : "white"
              };`,
            });
            Game.allTrainMarkers[train.id] = L.marker(train.latlng, {
              icon: marker,
            }).addTo(map);
            Game.allTrainMarkers[train.id].bindPopup(
              `列車 #${train.id} (Owner: ${train.owner})`
            );
          }
        });
      }

      function updateRankingUI(ranking) {
        const list = document.getElementById("ranking-list");
        list.innerHTML = "";
        // 3. 他の人のランキングで一人しか見えない: サーバー側で全ユーザーを取得するように修正したため、ここでは表示するだけ
        ranking.forEach((item, index) => {
          const li = document.createElement("li");
          li.innerHTML = `${index + 1}. <b>${item.userId}</b>: ¥${Math.round(
            item.score
          ).toLocaleString()}`;
          if (item.userId === Game.userId) {
            li.style.fontWeight = "bold";
            li.style.color = "#0044BB";
          }
          list.appendChild(li);
        });
      }

      // =========================================================
      // D. 建設・解体ロジック (サーバーにコマンド送信)
      // =========================================================

       function handleStationCreation(e) {
        if (Game.mode !== "station" || !socket) return;
        // 2. 範囲内に相手の駅があると立てれなくする: サーバー側でチェックを行う
        socket.emit("buildStation", { latlng: e.latlng });
      }

      function handleStationDismantle(station) {
        if (Game.mode !== "dismantle-station" || !socket) return;

        if (station.ownerId !== Game.userId) {
          alert("自分の駅しか解体できません。");
          return;
        }

        const dismantleCost = Math.round(STATION_COST * 0.1);
        if (
          confirm(
            `駅 ${
              station.id
            } を解体しますか？ (費用: ¥${dismantleCost.toLocaleString()})`
          )
        ) {
          socket.emit("dismantleStation", { stationId: station.id });
        }
      }

      function handleStationClick(station) {
        if (Game.mode === "track") {
          // 路線建設モード
          if (station.ownerId !== Game.userId) {
            alert("他プレイヤーの駅は路線のノードとして使用できません。");
            return;
          }

          if (lineCandidateNodes.includes(station)) return;

          lineCandidateNodes.push(station);

          const currentCoords = lineCandidateNodes.map((s) => [
            s.latlng.lat,
            s.latlng.lng,
          ]);

          if (currentCoords.length >= 2) {
            let weight = 7;
            if (Game.currentTrackType === "double") weight = 12;
            else if (Game.currentTrackType === "linear") weight = 15;
            else if (Game.currentTrackType === "tram") weight = 6;

            if (drawingPolyline) {
              drawingPolyline
                .setLatLngs(currentCoords)
                .setStyle({ color: "#C0C0C0", weight: weight });
            } else {
              drawingPolyline = L.polyline(currentCoords, {
                color: "#C0C0C0",
                weight: weight,
                opacity: 0.8,
                dashArray: "10, 10",
              }).addTo(map);
            }
          }
        } else if (Game.mode === "dismantle-station") {
          // 駅解体モード
          handleStationDismantle(station);
        }
      }

      function finalizeLine() {
        if (lineCandidateNodes.length < 2 || !socket) {
          alert("路線には2つ以上の駅が必要です。");
          return;
        }

        const stationCoords = lineCandidateNodes.map((s) => [
          s.latlng.lat,
          s.latlng.lng,
        ]);

        socket.emit("buildLine", {
          stationCoords: stationCoords,
          trackType: Game.currentTrackType,
        });

        if (drawingPolyline) map.removeLayer(drawingPolyline);
        lineCandidateNodes = [];
        drawingPolyline = null;
        toggleConstructionMode("idle");
      }

      function handleLineDismantle(e) {
        if (Game.mode !== "dismantle-line" || !socket) return;

        let closestLine = null;
        let closestLineId = null;
        let minDistance = Infinity;
        const lineSearchRadiusMeters = 50; // 50m以内を許容範囲とする

        // 🔹全ての路線を対象にする
        Object.entries(Game.allLines).forEach(([lineId, polyline]) => {
          const latlngs = polyline.getLatLngs();
          latlngs.forEach((latlng) => {
            const dist = e.latlng.distanceTo(latlng);
            if (dist < minDistance && dist < lineSearchRadiusMeters) {
              minDistance = dist;
              closestLine = polyline;
              closestLineId = lineId;
            }
          });
        });

        if (!closestLine || !closestLineId) {
          alert("クリックした位置の近くに解体できる路線が見つかりません。");
          return;
        }

        // 🔹lineIdからlineDataを取得
        // Game.establishedLines にはサーバーからコスト情報が含まれて送られてくることを前提とする
        const lineData = Game.establishedLines.find((l) => l.id == closestLineId);

        // 🔹オーナー確認（自分の路線しか解体できない）
        if (!lineData || lineData.ownerId !== Game.userId) {
          alert("自分の路線のみ解体可能です。");
          return;
        }

        // 修正: lineData.cost を使用
        const dismantleCost = Math.round(lineData.cost * 0.1);
        if (
          confirm(
            `路線 ${closestLineId} を解体しますか？ (費用: ¥${dismantleCost.toLocaleString()}、車両は購入価格の1/3で自動売却されます)`
          )
        ) {
          socket.emit("dismantleLine", { lineId: parseInt(closestLineId) });
        }
      }


      // =========================================================
      // E. UIとイベント処理
      // =========================================================

      function toggleConstructionMode(newMode) {
        const mapContainer = map.getContainer();

        L.DomUtil.removeClass(mapContainer, "station-mode");
        L.DomUtil.removeClass(mapContainer, "track-mode");
        L.DomUtil.removeClass(mapContainer, "dismantle-station-mode");
        L.DomUtil.removeClass(mapContainer, "dismantle-line-mode");

        map.off("click", handleStationCreation);
        map.off("click", handleLineDismantle);

        if (drawingPolyline) map.removeLayer(drawingPolyline);
        drawingPolyline = null;
        lineCandidateNodes = [];

        Game.mode = newMode;

        document
          .querySelectorAll(".rail-ui-control button")
          .forEach((btn) => btn.classList.remove("active"));

        if (newMode === "station") {
          L.DomUtil.addClass(mapContainer, "station-mode");
          document.getElementById("btn-station-mode").classList.add("active");
          map.on("click", handleStationCreation);
        } else if (newMode === "track") {
          L.DomUtil.addClass(mapContainer, "track-mode");
          document.getElementById("btn-track-mode").classList.add("active");
        } else if (newMode === "dismantle-station") {
          L.DomUtil.addClass(mapContainer, "dismantle-station-mode");
          document
            .getElementById("btn-dismantle-station-mode")
            .classList.add("active");
        } else if (newMode === "dismantle-line") {
          L.DomUtil.addClass(mapContainer, "dismantle-line-mode");
          document
            .getElementById("btn-dismantle-line-mode")
            .classList.add("active");
          map.on("click", handleLineDismantle);
        } else {
          document.getElementById("btn-station-mode").classList.add("active"); // アイドル状態の強調
        }
        
        // モード切り替え時に選択状態を復元
        const trackTypeSelect = document.getElementById("track-type");
        if (trackTypeSelect) {
            trackTypeSelect.value = Game.currentTrackType;
        }
      }

      function updateVehicleBuyUI() {
        const container = document.getElementById("vehicle-buy-container");
        container.innerHTML = `<h4>🚆 車両購入・路線割当</h4>`;

        if (Game.establishedLines.length === 0) {
          container.innerHTML += `<p>路線を建設すると車両が購入できます。</p>`;
          return;
        }

        if (Object.keys(VehicleData).length === 0) {
          container.innerHTML += `<p>車両データをサーバーから取得中...</p>`;
          return;
        }

        const sortedVehicleKeys = Object.keys(VehicleData).sort(
          (a, b) =>
            VehicleData[a].purchaseMultiplier -
            VehicleData[b].purchaseMultiplier
        );

        sortedVehicleKeys.forEach((key) => {
          const data = VehicleData[key];
          const purchaseCost = VEHICLE_BASE_COST * data.purchaseMultiplier;

          const availableLines = Game.establishedLines.filter((line) => {
            const isLinear = data.name === "リニア";

            if (isLinear) return line.trackType === "linear";
            if (line.trackType === "linear") return false;

            return true;
          });

          const lineSelect = `<select id="line-select-${key}" style="width: 50%; margin-right: 5px;">
                    ${availableLines
                      .map(
                        (line) =>
                          `<option value="${line.id}">Line ${line.id} (${line.trackType})</option>`
                      )
                      .join("")}
                </select>`;

          const disabled = availableLines.length === 0 ? "disabled" : "";

          container.innerHTML += `
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <span style="width: 100px; color: ${data.color};">${
            data.name
          }</span>
                        <small style="flex-grow: 1; margin-left: 10px;">${
                          data.maxSpeedKmH
                        }km/h, ¥${purchaseCost.toLocaleString()}</small>
                        ${lineSelect}
                        <button onclick="buyVehicle('${key}')" style="width: 45%;" ${disabled}>購入</button>
                    </div>
                `;
        });
      }

      window.buyVehicle = (vehicleKey) => {
        if (!socket) return alert("サーバーに接続されていません。");
        const lineSelect = document.getElementById(`line-select-${vehicleKey}`);
        if (!lineSelect || lineSelect.value === "") {
          alert("割り当てる路線を選択してください。");
          return;
        }
        const lineId = lineSelect.value;

        socket.emit("buyVehicle", { lineId: lineId, vehicleKey: vehicleKey });
      };

      window.toggleAccordion = (contentId) => {
        const content = document.getElementById(contentId);
        const header = content.previousElementSibling;
        const icon = header.querySelector("span:last-child");

        content.classList.toggle("open");
        if (content.classList.contains("open")) {
          icon.textContent = "▼";
        } else {
          icon.textContent = "▲";
        }
      };

      window.handleLogin = handleLogin;
      window.toggleConstructionMode = toggleConstructionMode;
      window.finalizeLine = finalizeLine;
      window.Game = Game;

      document.addEventListener("DOMContentLoaded", () => {
        // 1. Leafletマップの初期化を最初に行う
        // 💡 修正: worldCopyJump: true と noWrap: false を追加し、ワールドラッピングを有効化
        map = L.map("map", {
            worldCopyJump: true, // マーカーやポリラインがワールドコピー間で正しく表示されるようにする
            noWrap: false // 経度方向の無限スクロールを有効にする (デフォルトだが明示)
        }).setView([INITIAL_LAT, INITIAL_LNG], 13);
        
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "© OpenStreetMap contributors (Base)",
          maxZoom: 19,
          noWrap: false // タイルレイヤー側でも無限スクロールを有効にする
        }).addTo(map);
        
        L.tileLayer(
          "https://cyberjapandata.gsi.go.jp/xyz/dem5a_color/{z}/{x}/{y}.png",
          { attribution: "国土地理院", opacity: 0.5 }
        ).addTo(map);

        // 2. UIコントロールをマップに追加
        const controlDiv = document.querySelector(".rail-ui-control");
        const controlHtml = controlDiv.innerHTML;
        controlDiv.remove();

        const constructControl = L.control({ position: "topleft" });
        constructControl.onAdd = function (map) {
          const div = L.DomUtil.create("div", "rail-ui-control");
          div.innerHTML = controlHtml;
          L.DomEvent.disableClickPropagation(div);
          
          // 要素がDOMに追加された直後に選択値を復元
          const trackTypeSelect = div.querySelector("#track-type");
          if (trackTypeSelect) {
              trackTypeSelect.value = Game.currentTrackType;
          }
          
          return div;
        };
        constructControl.addTo(map);

        // 3. 建設モードの初期化
        toggleConstructionMode("idle");

        // 4. ログイン処理
        const savedUserId = getCookie("userId");
        if (savedUserId) {
          document.getElementById("username-input").value = savedUserId;
        }
      });
    </script>
  </body>
</html>
